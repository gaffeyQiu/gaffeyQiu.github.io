<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on gaffey的开发日志</title>
    <link>https://blog.7bao.fun/post/</link>
    <description>Recent content in Posts on gaffey的开发日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Feb 2022 11:19:41 +0800</lastBuildDate><atom:link href="https://blog.7bao.fun/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang Sync.Mutex 使用及原理</title>
      <link>https://blog.7bao.fun/p/golang-sync.mutex-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 24 Feb 2022 11:19:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/golang-sync.mutex-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
      <description>Golang Sync.Mutex 使用及原理 使用 func main() { var mu sync.Mutex var count = 0 var wg sync.WaitGroup for i := 0; i &amp;lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() mu.Lock() count++ mu.Unlock() }() } wg.Wait() fmt.Println(count) } 实现 首先看 Mutex 到底是什么数据结构
type Mutex struct { state int32 sema uint32 } sema 信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒 state uint32 字段被分成了四部分,这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，第三位表示是否进入饥饿模式，剩余的位数代表的是等待此锁的 goroutine 数
const ( mutexLocked = 1 &amp;lt;&amp;lt; iota // mutex is locked  mutexWoken //2  mutexStarving //3  mutexWaiterShift = iota //4 } ``` &amp;gt;为了保证锁的公平性，设计上互斥锁有两种状态：正常状态和饥饿状态。 &amp;gt; &amp;gt;`正常模式`下，所有等待锁的goroutine按照FIFO顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。新请求锁的goroutine具有优势：它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。 `如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式`。 &amp;gt; &amp;gt;`饥饿模式`下，锁的所有权将从unlock的gorutine直接交给交给等待队列中的第一个。新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。 &amp;gt; &amp;gt;如果一个等待的goroutine获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。 正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。 #### Mutex.</description>
    </item>
    
    <item>
      <title>Golang Sync.Pool 原理</title>
      <link>https://blog.7bao.fun/p/golang-sync.pool-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 24 Feb 2022 11:19:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/golang-sync.pool-%E5%8E%9F%E7%90%86/</guid>
      <description>Golang Sync.Pool 原理分析  
Get func (p *Pool) Get() interface{} { // 把当前goroutine固定在当前的P上 	l, pid := p.pin() x := l.private // 优先从local的private字段取，快速 	l.private = nil if x == nil { // 从当前的local.shared弹出一个，注意是从head读取并移除 	x, _ = l.shared.popHead() if x == nil { // 如果没有，则去偷一个 	x = p.getSlow(pid) } } runtime_procUnpin() // 如果没有获取到，尝试使用New函数生成一个新的 	if x == nil &amp;amp;&amp;amp; p.New != nil { x = p.New() } return x }  首先，从本地的 private 字段中获取可用元素，因为没有锁，获取元素的过程会非常快 如果没有获取到，就尝试从本地的 shared 获取一个 如果还没有，会使用 getSlow 方法去其它的 shared 中“偷”一个 最后，如果没有获取到，就尝试使用 New 函数创建一个新的。  Put func (p *Pool) Put(x interface{}) { if x == nil { // nil值直接丢弃 	return } l, _ := p.</description>
    </item>
    
    <item>
      <title>Golang Sync.WaitGroup 使用及原理</title>
      <link>https://blog.7bao.fun/p/golang-sync.waitgroup-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 24 Feb 2022 11:17:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/golang-sync.waitgroup-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
      <description>Golang Sync.WaitGroup 使用及原理 使用 func main() { var wg sync.WaitGroup for i := 0; i &amp;lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() fmt.Println(&amp;#34;Hello WaitGroup!&amp;#34;) }() } wg.Wait() } 实现 首先看 waitgroup 到底是什么数据结构
type WaitGroup struct { noCopy noCopy state1 [3]uint32 } nocopy 避免这个结构体被复制的一个技巧，可以告诉go vet工具违反了复制使用的规则 state1 [3]uint32 字段中包含了 waitgroup 的所有状态信息, 根据标准库上自带的注释简单翻译是：state1 由 12 个字节组成，其中将8字节看作64位值，其中高32位存放的是 counter 计数器, 代表目前还未完成的 goroutine个数，低32位存放的是 waiter 计数器, 可以理解成下面这个结构体
type WaitGroup struct { // 代表目前尚未完成的个数 	// WaitGroup.</description>
    </item>
    
    <item>
      <title>进程调度</title>
      <link>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Thu, 24 Feb 2022 10:00:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid>
      <description>交互式系统在个人计算机，服务器和其他类系统中都是常用的
1. 轮转调度（round robin） 一种最古老，最简单，最公平且使用最广的算法。 每个进程被分配一个时间段，称为时间片（quantum），如果在时间片结束时该进程还在运行，则剥夺CPU并分配给另一个进程。如果该进程在时间片内阻塞或结束，则CPU立即切换。
 时间片通常设置为 20 ～ 50ms，因为太短会频繁上下文切换，太长可能导致程序响应变长
 2. 优先级调度 为每个进程赋予一个优先级，允许优先级高的进程先执行
3. 多级队列（CTSS） 先设立优先级类，最高优先级类的进程运行1个时间片，次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推，当一个进程用完分配的时间片后，它被移到下一类，如果是遇到需要交互输入的进程，为了避免等待用户输入的时候，被调度算法安排到比较底的优先级中，按下回车键，就会把该进程提高到最高优先级类中。
4. 最短进程优先 根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。
5. 保证调度 由于各个进程实际获得的CPU时间是已知的，所以可以计算出真正获得CPU时间和应该获得CPU时间的比例，比率为0.5则说明当前进程仅获得了应得时间的一半，而 2.0 则说明该进程获得了双倍的应得时间，于是算法随后转向比率最低的进程
6. 彩票调度 为进程提供各种系统资源的彩票，一旦要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程可以获得资源。同时可以给更重要的进程分配更多的彩票，以便增加它们获胜的机会。
7. 公平分享调度 假设用户1启动了9个进程，而用户2只有一个进程，使用轮转或相同优先级的算法， 用户1能获得90%的CPU时间，而用户2只能得到10%的CPU时间
为了避免这一情况，某些系统在调度处理之前考虑谁拥有进程这一因素。
线程的调度 用户级线程 内核不知道线程的存在，假设A，B进程都运行了若干个线程， 那么CPU运行进程A时，此时进程A中的线程A1，A2，A3 按照顺序依次执行直到当前时间片结束，然后切换到进程B执行。其中线程执行的顺序则有进程保证。
内核级线程 内核会从AB两个进程中选择一个特定的线程来执行，它不用考虑该线程属于哪个进程（如果有必要，也可以考虑），对被选择的进程赋予一个时间片，当超过时间片时候，强制挂起该线程。这样执行顺序可能是 A1，B1，A2，B2
区别 用户级线程和内核级线程性能相差很大，用户级线程切换需要少量的机器指令，而内核线程切换则需要上下文切换，修改内存映象，使高速缓存失效，这导致了若干数量级的延迟。 另一方面，一旦线程阻塞在一个I/O上，不需要像用户级线程中将整个进程挂起。 另一个重要因素是用户级线程可以使用专门的调度程序，而内核级线程则无法为某个进程定制调度策略。所以用户级线程性能会更好。</description>
    </item>
    
    <item>
      <title>进程间通信（Inter Process Communication）</title>
      <link>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1inter-process-communication/</link>
      <pubDate>Thu, 24 Feb 2022 10:00:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1inter-process-communication/</guid>
      <description>进程间通信 （Inter Process Communication） 竞争条件（race condition） 前提 书中举了一个脱机打印程序的例子，当一个进程需要打印一个文件，它将需要打印的文件名放在一个特殊的目录下（脱机目录），另一个进程则周期性的检查是否有文件需要打印，如果有就打印这个文件并将文件名从这个目录下删掉。
假设这个目录下有很多格子，每个格子可以放一个文件名，还有两个共享变量 in 和 out out 指向下一个要打印的文件名，in 指向目录中下一个空闲的格子。这两个变量能同时被这两个进程访问到。
场景   在某一时刻， 4～6 号格子被需要打印的文件名占用。 在同一时刻，进程A 和 进程B 都决定要打印一个文件，会发生的可能情况：
A 读到 in 的值为 7，然后将 7 存在自己进程的一个变量中 next_free_slot, 此时发生一次时钟中断，CPU 切换到 B，进程 B 也读到 in 的值为 7，同样存放到自己进程变量 next_free_slot 中，结果这两个进程都认为下一个可用格子为 7， B 接着运行，它将需要打印的文件名写入 7 号格子中，并更新 in 的值为 8，然后进程B执行结束，换到 进程A 从上次中断的地方执行， A 检查自己的 next_free_slot 为 7，于是把文件名写入到 7 号格子中，修改 in 的值为 8， 出现的结果就是 进程B 需要打印的文件名被覆盖掉， 导致进程B需要打印的文件不会被打印机打印， 程序也不会发生任何错误。
类似这样的情况， 称为 竞争条件（race condition）</description>
    </item>
    
    <item>
      <title>[操作系统实验] ucore 环境准备</title>
      <link>https://blog.7bao.fun/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-ucore-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</link>
      <pubDate>Wed, 22 Dec 2021 22:38:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-ucore-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</guid>
      <description>[实验] ucore 环境准备 环境准备 1. 准备一台装有 ubuntu 操作系统的机器 建议是在虚拟机里面安装一个 ubuntu， 避免对自己机器的影响， 我安装的是当时最新版本ubuntu桌面端
 https://ypy.7bao.fun/img/20211222204823.png 
ps：小豹子挺可爱的
2. 安装环境  gcc: 编译 c++ make: 自动编译或测试代码 gdb: 调试代码 cgdb: 字符方式调试代码 qemu: 调试内核，实验中搭配 cgdb 使用 git: 获取实验所需代码 vscode: 编写代码 vim: 偶尔也会在终端用 vim 查看代码  3. 实验资料 https://github.com/chyyuu/os_course_info
Introduction
Introduction
4. 获取代码 根据实验资料查到项目地址，非常友好的开源了，没有放在清华的内网。
git clone &amp;lt;https://github.com/chyyuu/os_kernel_lab.git 这样获取到的代码默认是 rust 语言实现的，目前我学习的是 c 语言实现，所以切换到 master 分支 （后续实验完成了希望能用 rust 也实现一遍)
git checkout master 5.验证环境 可以参考视频 学堂在线 2.7 演示实验操作过程</description>
    </item>
    
    <item>
      <title>[翻译]How Does a Database Work?</title>
      <link>https://blog.7bao.fun/p/%E7%BF%BB%E8%AF%91how-does-a-database-work/</link>
      <pubDate>Fri, 17 Dec 2021 16:08:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/%E7%BF%BB%E8%AF%91how-does-a-database-work/</guid>
      <description>数据库是如何工作的?  数据在磁盘或内存中以什么格式保存？ 它什么时候从内存移动到磁盘？//todo 为什么一张表只能有一个主键？ 事务如何回滚？ 索引是如何格式化的？//todo 何时以及如何进行全表扫描？ 准备好的语句保存格式是什么？  简而言之，数据库是如何工作的？
我正在用 C 从头开始构建一个 sqlite 的副本，以便理解，我将在进行的过程中记录我的过程
目录  Part1 -  reference  https://cstack.github.io/db_tutorial
 </description>
    </item>
    
    <item>
      <title>Goland 使用技巧</title>
      <link>https://blog.7bao.fun/p/goland-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 03 Dec 2021 13:17:01 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/goland-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>显示函数的参数 (cmd + p)   实现接口 (ctrl + i) (cmd + n)  
生成测试 (cmd + shift + t) (cmd + n)   在打开的文件之间导航 (ctrl + tab)     最近的文件 (cmd + e)   查看结构体窗口 (cmd + F12)   调用层次接口 (ctrl + alt + h)   显示引用 (alt + F7)   历史剪贴板 (cmd + shift + v)   打开/关闭终端 (alt + F12) 跳转到定义或引用 (cmd + b) 前进/后退 (cmd + [) (cmd + ]) 自动填充结构体 (alt + enter)   快速显示定义 (cmd + y)</description>
    </item>
    
    <item>
      <title>Gin 如何动态生成模型 swagger 文档</title>
      <link>https://blog.7bao.fun/p/gin-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B-swagger-%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 01 Dec 2021 19:17:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/gin-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B-swagger-%E6%96%87%E6%A1%A3/</guid>
      <description>在做 API 接口开发时, 一般会统一 API 返回格式, 例如
{ &amp;#34;code&amp;#34;: 200, &amp;#34;data&amp;#34;: { //xxxxx  //xxxxx  }, &amp;#34;message&amp;#34;: &amp;#34;OK&amp;#34; } 在后端代码定义中, 也会定义一个结构体来对应这种结构, 并且, 由于 data 字段里的数据是未知的(与具体业务相关), 所以会定义一个 interface 来接收
type ApiResponse struct { Code int `json:&amp;#34;code&amp;#34;` Msg string `json:&amp;#34;message&amp;#34;` Data interface{} `json:&amp;#34;data&amp;#34;` } 然后根据具体业务响应, 向 data 传入不同的模型, 比如
c.JSON(200, ApiResponse{200, &amp;#34;OK&amp;#34;, User}) 但是这里有个很大的问题, swagger 文档中, 这个接口的返回值该怎么定义?
// @Summary 获取用户信息 // ... // ... // @Success 200 {object} ApiResponse &amp;#34;ok&amp;#34; func GetUser(c *gin.</description>
    </item>
    
    <item>
      <title>GVK 和 GVR 的区别</title>
      <link>https://blog.7bao.fun/p/gvk-%E5%92%8C-gvr-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 01 Dec 2021 11:37:00 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/gvk-%E5%92%8C-gvr-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>在查看或者编写 k8s API 的时候, 经常会看到四个术语 groups versions kinds resources 其中大多数以组合的形式出现, 分别为 GVK GVR, 这两个术语很容易弄混, 接下来讲讲他们的区别.
Group 和 Version Group 和 Version 很好理解, 在 k8s 用 yaml 清单部署过服务的都应该看到过这个字段
apiVersion:apps/v1kind:xxxmetadata:上面例子中, apps 就是 group, version 是 v1, 每个 group 可以包含多个 version, 这样的关系可以随着时间的推移, 创建多个不同 version 来兼容更多的 api 改动
特殊的, 有的资源没有 group, 只有 version, 例如 pod, 这类被称为核心资源组  
 其中 Alpha 是内测版本, 一般不建议使用, 如 v1alpha1, Beta 是经过测试的相对稳定版, 如 v1beta1, Stable 是正式发布版 如 v1, v2</description>
    </item>
    
    <item>
      <title>VsCode 使用技巧</title>
      <link>https://blog.7bao.fun/p/vscode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Wed, 17 Nov 2021 15:17:01 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/vscode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>vscode 配置或快捷键  cmd + j 打开或关闭终端 F12 或 ctrl + ] 跳转到函数定义处 gh 显示鼠标 hover 在当前位置时提示的信息 ctrl + i 前进 ctrl + o 后退 alt + F8 光标定位到当前页面问题代码 cmd + . 快速修复问题代码 ctrl + Enter 水平分屏方式打开文件  vscode json 配置项  Go 语言静态检查配置  staticcheck是针对go的静态检查工具，文档地址 在 setting.json 中过滤掉对应的编号(例如过滤掉 ST1020 和 所有 S1 开头的规则) &amp;#34;go.lintFlags&amp;#34;: [ &amp;#34;-checks&amp;#34;, &amp;#34;all,-ST1020,-S1*&amp;#34; ]     vim 自身按键  {number} + w 向前移动 N 个单词 {number} + b 向后移动 N 个单词 % 跳转到匹配的括号 ctrl + ] + gd 跳转到函数定义处 gh 显示鼠标 hover 在当前位置时提示的信息 {number} + f + {char} 向右移动到第 N 个指定字符处 zt/zz/zb 光标跳转到屏幕的顶/中/底部 {number} + ctrl + E 向上滚屏 {number} + ctrl + Y 向上滚屏 ctrl + c 退出插入模式  vim 插件快捷键  ds&amp;quot; 删除 &amp;ldquo;abc&amp;rdquo; 的双引号 cs&amp;quot;&#39; 替换 &amp;ldquo;abc&amp;rdquo; 为 &amp;lsquo;abc&amp;rsquo; ysw&amp;quot; 添加&amp;quot;&amp;ldquo;给一个单词 S&amp;quot; 选中 abc 的情况下, 给 abc 加上双引号  </description>
    </item>
    
    <item>
      <title>VsCode 插件分享</title>
      <link>https://blog.7bao.fun/p/vscode-%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/</link>
      <pubDate>Tue, 16 Nov 2021 20:34:44 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/vscode-%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/</guid>
      <description>主题类 1. Material Icon Theme  功能说明: 可以给文件夹和文件自动添加 icon, 这个是同类插件中看起来最舒服的 使用说明: 安装完成后即可使用  image.png   2. One Dark Pro  功能说明: vscode 使用人数比较多的主题 使用说明: 安装完成后即可使用
 image.png   3. Darcula IntelliJ Theme  功能说明: 如果你习惯 jetbrains 家的 IDE, 这个 vscode 主题绝对适合你 使用说明: 安装完成后即可使用  image.png   效率类 1. Git Graph  功能说明: 一款 git 可视化插件, 非常好看而且实用 使用说明: 安装完成后即可使用    2. Docker  功能说明: Dockerfile 提示, 管理本地 docker 服务 安装完成后即可使用     &amp;hellip;不定期补充</description>
    </item>
    
    <item>
      <title>HelloBlog</title>
      <link>https://blog.7bao.fun/p/helloblog/</link>
      <pubDate>Thu, 11 Nov 2021 16:17:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/helloblog/</guid>
      <description>按照国际惯例, 新的博客有一篇 hello 文章, 一来是测试新博客是否运行正常, 二来是记录下为什么要来建个人博客吧.
其实, 在 2021 年建个人博客应该不太流行了, 现在国内大部分技术类文章基本上都在博客园或者CSDN 这些社区, 我在刚学 PHP 那会, 就租了 3 年的云服务器建个人博客, 学习 Linux 命令和 LNMP 技术栈后来, 但是限于当时懒+技术理解不深, 比如安装环境, 配置域名, 发表的博客带图片的话加载巨慢,因为当时带宽是买的 1M 的, 还要建一个 Mysql 数据库, 还被黑过一次, 当时用的 root@root 这种弱密码并且放开所有权限等等等等, 后来索性就当 Linux 学习机玩了, 文章在偶尔会在知乎上写写.
最近这种静态博客特别火, 没有服务器, 只需要一个域名(也可以没有), 就可以建一个自己的后花园, 感觉非常不错, 借助 githubAction 甚至都不用自己打包, 平常空闲了学习了什么, 可以写写当做知识的巩固, 毕竟看过不等于会, 讲得出来才叫会, 顺便锻炼一下自己的表达能力, 我觉得这项技能对开发来说尤为重要.</description>
    </item>
    
  </channel>
</rss>
