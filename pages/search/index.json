[{"content":"[实验] ucore 环境准备 环境准备 1. 准备一台装有 ubuntu 操作系统的机器 建议是在虚拟机里面安装一个 ubuntu， 避免对自己机器的影响， 我安装的是当时最新版本ubuntu桌面端\n https://ypy.7bao.fun/img/20211222204823.png \nps：小豹子挺可爱的\n2. 安装环境  gcc: 编译 c++ make: 自动编译或测试代码 gdb: 调试代码 cgdb: 字符方式调试代码 qemu: 调试内核，实验中搭配 cgdb 使用 git: 获取实验所需代码 vscode: 编写代码 vim: 偶尔也会在终端用 vim 查看代码  3. 实验资料 https://github.com/chyyuu/os_course_info\nIntroduction\nIntroduction\n4. 获取代码 根据实验资料查到项目地址，非常友好的开源了，没有放在清华的内网。\ngit clone \u0026lt;https://github.com/chyyuu/os_kernel_lab.git 这样获取到的代码默认是 rust 语言实现的，目前我学习的是 c 语言实现，所以切换到 master 分支 （后续实验完成了希望能用 rust 也实现一遍)\ngit checkout master 5.验证环境 可以参考视频 学堂在线 2.7 演示实验操作过程\n# 进入代码 lab1 的答案目录 cd os_kernel_lab/labcodes_answer/lab1_result # 清理上次构建的产物（首次可以不用清理） make clean # 启动 qemu make qemu  https://ypy.7bao.fun/img/20211222210237.png \n能成功看到不停的有 ticks 输出即可\n6. 如何 Debug   使用 cgdb 调试 在每个 lab 的目录下执行 make debug, 即可弹出 debug 界面\n https://ypy.7bao.fun/img/20211222222409.png \n  使用 vscode 调试 效果上比 cgdb 强了不少，可惜不能调试 bootmain.c\n需要预先填好下面的 vscode debug 配置文件\nlaunch.json 文件\n{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: \u0026lt;https://go.microsoft.com/fwlink/?linkid=830387\u0026gt; \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc - 生成和调试活动文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;miDebuggerServerAddress\u0026#34;: \u0026#34;localhost:1234\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/bin/kernel\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;make-gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/usr/bin/gdb\u0026#34; } ] } tasks.json 文件\n{ \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;make-gdb\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;make\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;gdb\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;isBackground\u0026#34;: true, \u0026#34;problemMatcher\u0026#34;: { \u0026#34;pattern\u0026#34;: { \u0026#34;regexp\u0026#34;: \u0026#34;.\u0026#34; }, \u0026#34;background\u0026#34;: { \u0026#34;activeOnStart\u0026#34;: true, \u0026#34;beginsPattern\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;endsPattern\u0026#34;: \u0026#34;.\u0026#34; }, }, } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 点击 vscode 的 debug 按钮， 会出现如图所示的效果\n https://ypy.7bao.fun/img/20211222222255.png \n  ","date":"2021-12-22T22:38:41+08:00","image":"https://ypy.7bao.fun/img/xps-EzYq1HOl5_8-unsplash.jpg","permalink":"https://blog.7bao.fun/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-ucore-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/","title":"[操作系统实验] ucore 环境准备"},{"content":"数据库是如何工作的?  数据在磁盘或内存中以什么格式保存？ 它什么时候从内存移动到磁盘？//todo 为什么一张表只能有一个主键？ 事务如何回滚？ 索引是如何格式化的？//todo 何时以及如何进行全表扫描？ 准备好的语句保存格式是什么？  简而言之，数据库是如何工作的？\n我正在用 C 从头开始构建一个 sqlite 的副本，以便理解，我将在进行的过程中记录我的过程\n目录  Part1 -  reference  https://cstack.github.io/db_tutorial\n ","date":"2021-12-17T16:08:41+08:00","image":"https://ypy.7bao.fun/img/jonathan-arbely-477E0cXoc1c-unsplash.jpeg","permalink":"https://blog.7bao.fun/p/%E7%BF%BB%E8%AF%91how-does-a-database-work/","title":"[翻译]How Does a Database Work?"},{"content":"显示函数的参数 (cmd + p)   实现接口 (ctrl + i) (cmd + n)  \n生成测试 (cmd + shift + t) (cmd + n)   在打开的文件之间导航 (ctrl + tab)     最近的文件 (cmd + e)   查看结构体窗口 (cmd + F12)   调用层次接口 (ctrl + alt + h)   显示引用 (alt + F7)   历史剪贴板 (cmd + shift + v)   打开/关闭终端 (alt + F12) 跳转到定义或引用 (cmd + b) 前进/后退 (cmd + [) (cmd + ]) 自动填充结构体 (alt + enter)   快速显示定义 (cmd + y)  \n","date":"2021-12-03T13:17:01+08:00","image":"https://ypy.7bao.fun/img/20211204191404.png","permalink":"https://blog.7bao.fun/p/goland-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"Goland 使用技巧"},{"content":"在做 API 接口开发时, 一般会统一 API 返回格式, 例如\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;data\u0026#34;: { //xxxxx  //xxxxx  }, \u0026#34;message\u0026#34;: \u0026#34;OK\u0026#34; } 在后端代码定义中, 也会定义一个结构体来对应这种结构, 并且, 由于 data 字段里的数据是未知的(与具体业务相关), 所以会定义一个 interface 来接收\ntype ApiResponse struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;message\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } 然后根据具体业务响应, 向 data 传入不同的模型, 比如\nc.JSON(200, ApiResponse{200, \u0026#34;OK\u0026#34;, User}) 但是这里有个很大的问题, swagger 文档中, 这个接口的返回值该怎么定义?\n// @Summary 获取用户信息 // ... // ... // @Success 200 {object} ApiResponse \u0026#34;ok\u0026#34; func GetUser(c *gin.Context) { xxxx } 如果这样定义, 生成的文档会是下面这样, 因为原始 ApiResponse 就是一个 interface, 所以是空  \n但是这样的文档写出来就没什么意义了, 大多数的做法就是会专门定义一个用于 swagger 显示的结构体, 类似这样\ntype UserResponse struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;message\u0026#34;` Data User `json:\u0026#34;data\u0026#34;` } 虽然效果有了, 但是这样无疑增加了巨多的工作量, 让写代码变得索然无味, 翻看 swaggo/swag 的文档, 发现支持了替换字段的方式, 可以完美解决现在这种问题, 效果如下  \n下面是测试代码\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // @title Swagger Example API // @version 1.0 // @description This is a sample server Petstore server. // @termsOfService http://swagger.io/terms/  // @contact.name API Support // @contact.url http://www.swagger.io/support // @contact.email support@swagger.io  // @license.name Apache 2.0 // @license.url http://www.apache.org/licenses/LICENSE-2.0.html  // @host petstore.swagger.io // @BasePath /v2 func main() { r := gin.New() r.GET(\u0026#34;/user/:id\u0026#34;, GetUser) } // @Summary 获取用户信息 // @Description get User by ID // @ID get-user-by-id // @Accept json // @Produce json // @Param id path int true \u0026#34;用户 id\u0026#34; // @Success 200 {object} ApiResponse{data=User} \u0026#34;ok\u0026#34; // @Router /user/{id} [get] func GetUser(c *gin.Context) { resp := new(ApiResponse) paramID := c.Param(\u0026#34;id\u0026#34;) uid, _ := strconv.Atoi(paramID) user := User{ ID: uid, Name: \u0026#34;张三\u0026#34;, } resp.Code = 200 resp.Msg = \u0026#34;OK\u0026#34; resp.Data = user c.JSON(http.StatusOK, resp) } type User struct { ID int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } type ApiResponse struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;message\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } ","date":"2021-12-01T19:17:41+08:00","image":"https://ypy.7bao.fun/img/20211201201550.png","permalink":"https://blog.7bao.fun/p/gin-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B-swagger-%E6%96%87%E6%A1%A3/","title":"Gin 如何动态生成模型 swagger 文档"},{"content":"在查看或者编写 k8s API 的时候, 经常会看到四个术语 groups versions kinds resources 其中大多数以组合的形式出现, 分别为 GVK GVR, 这两个术语很容易弄混, 接下来讲讲他们的区别.\nGroup 和 Version Group 和 Version 很好理解, 在 k8s 用 yaml 清单部署过服务的都应该看到过这个字段\napiVersion:apps/v1kind:xxxmetadata:上面例子中, apps 就是 group, version 是 v1, 每个 group 可以包含多个 version, 这样的关系可以随着时间的推移, 创建多个不同 version 来兼容更多的 api 改动\n特殊的, 有的资源没有 group, 只有 version, 例如 pod, 这类被称为核心资源组  \n 其中 Alpha 是内测版本, 一般不建议使用, 如 v1alpha1, Beta 是经过测试的相对稳定版, 如 v1beta1, Stable 是正式发布版 如 v1, v2\n Kind 这个字段第一次接触应该是在 yaml 清单, 常见的有 pod, deployment, service 等, 它结合 apiVersion 能确定一个具体的 API 类型, 比如下面的 yaml 清单能定位到一种 API 类型\napiVersion:apps/v1kind:DaemonSetmetadata:name:node-exporter但是有了这个 apiVersion 和 kind , kubectl 如何转化成 http rest 请求发送到 apiServer 的呢? 这就需要用到 Resource 了\nResources 有了 Resource , 搭配 group 和 version, 就能很轻易的知道对应的资源 rest url, 比如 deployment, 它的 apiVersion 是 apps/v1, 就可以查询集群中某个命名空间下的 deployment 列表.\nGET /apis/apps/v1/deployments // 也可以限定命名空间查询 /apis/apps/v1/namespaces/${namespace}/deployments { \u0026#34;kind\u0026#34;: \u0026#34;DeploymentList\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;apps/v1\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/apps/v1/namespaces/tke/deployments\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;4819273\u0026#34; }, \u0026#34;items\u0026#34;: [ { \u0026#34;metadata\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;tke-auth-api\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;tke\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/apps/v1/namespaces/tke/deployments/tke-auth-api\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;28979433-72d2-40d0-8555-038bdd8b95ca\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;1344\u0026#34;, \u0026#34;generation\u0026#34;: 1, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2021-11-22T08:13:44Z\u0026#34;, \u0026#34;labels\u0026#34;: { \u0026#34;app\u0026#34;: \u0026#34;tke-auth-api\u0026#34; }, \u0026#34;annotations\u0026#34;: { \u0026#34;deployment.kubernetes.io/revision\u0026#34;: \u0026#34;1\u0026#34; }, ... ... 可以发现, resouce 和 kind 区别并不大, 拿上面的例子来说, kind 是 deployment, resource 也是 deployment, 但是光知道 GVK, 只能知道是一个什么类型的 API, 但是知道 GVR, 就能知道具体的资源, 有点类似于面向对象的 类 和 对象 的区别, Kind 类似 User 类, 那么 new User(张三) 就是对应的 Resource 了\n 通常情况下 Kind 和 Resource 是一一对应的, Scale Kind 可能对应很多 Resources：deployments/scale 或者 replicasets/scale, 而且 Resource 始终是小写形式，并且通常情况下是 Kind 的小写\n GVK GVR 互转 编码过程中, 如果遇到这两种类型, 可以通过 RESTMapper 进行互相转换\ntype RESTMapper interface { // KindFor takes a partial resource and returns the single match. Returns an error if there are multiple matches \tKindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error) // KindsFor takes a partial resource and returns the list of potential kinds in priority order \tKindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error) // ResourceFor takes a partial resource and returns the single match. Returns an error if there are multiple matches \tResourceFor(input schema.GroupVersionResource) (schema.GroupVersionResource, error) // ResourcesFor takes a partial resource and returns the list of potential resource in priority order \tResourcesFor(input schema.GroupVersionResource) ([]schema.GroupVersionResource, error) // RESTMapping identifies a preferred resource mapping for the provided group kind. \tRESTMapping(gk schema.GroupKind, versions ...string) (*RESTMapping, error) // RESTMappings returns all resource mappings for the provided group kind if no \t// version search is provided. Otherwise identifies a preferred resource mapping for \t// the provided version(s). \tRESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error) ResourceSingularizer(resource string) (singular string, err error) } ","date":"2021-12-01T11:37:00+08:00","image":"https://ypy.7bao.fun/img/20211201134543.png","permalink":"https://blog.7bao.fun/p/gvk-%E5%92%8C-gvr-%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"GVK 和 GVR 的区别"},{"content":"vscode 配置或快捷键  cmd + j 打开或关闭终端 F12 或 ctrl + ] 跳转到函数定义处 gh 显示鼠标 hover 在当前位置时提示的信息 ctrl + i 前进 ctrl + o 后退 alt + F8 光标定位到当前页面问题代码 cmd + . 快速修复问题代码 ctrl + Enter 水平分屏方式打开文件  vscode json 配置项  Go 语言静态检查配置  staticcheck是针对go的静态检查工具，文档地址 在 setting.json 中过滤掉对应的编号(例如过滤掉 ST1020 和 所有 S1 开头的规则) \u0026#34;go.lintFlags\u0026#34;: [ \u0026#34;-checks\u0026#34;, \u0026#34;all,-ST1020,-S1*\u0026#34; ]     vim 自身按键  {number} + w 向前移动 N 个单词 {number} + b 向后移动 N 个单词 % 跳转到匹配的括号 ctrl + ] + gd 跳转到函数定义处 gh 显示鼠标 hover 在当前位置时提示的信息 {number} + f + {char} 向右移动到第 N 个指定字符处 zt/zz/zb 光标跳转到屏幕的顶/中/底部 {number} + ctrl + E 向上滚屏 {number} + ctrl + Y 向上滚屏 ctrl + c 退出插入模式  vim 插件快捷键  ds\u0026quot; 删除 \u0026ldquo;abc\u0026rdquo; 的双引号 cs\u0026quot;' 替换 \u0026ldquo;abc\u0026rdquo; 为 \u0026lsquo;abc\u0026rsquo; ysw\u0026quot; 添加\u0026quot;\u0026ldquo;给一个单词 S\u0026quot; 选中 abc 的情况下, 给 abc 加上双引号  ","date":"2021-11-17T15:17:01+08:00","permalink":"https://blog.7bao.fun/p/vscode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"VsCode 使用技巧"},{"content":"主题类 1. Material Icon Theme  功能说明: 可以给文件夹和文件自动添加 icon, 这个是同类插件中看起来最舒服的 使用说明: 安装完成后即可使用  image.png   2. One Dark Pro  功能说明: vscode 使用人数比较多的主题 使用说明: 安装完成后即可使用\n image.png   3. Darcula IntelliJ Theme  功能说明: 如果你习惯 jetbrains 家的 IDE, 这个 vscode 主题绝对适合你 使用说明: 安装完成后即可使用  image.png   效率类 1. Git Graph  功能说明: 一款 git 可视化插件, 非常好看而且实用 使用说明: 安装完成后即可使用    2. Docker  功能说明: Dockerfile 提示, 管理本地 docker 服务 安装完成后即可使用     \u0026hellip;不定期补充\n ","date":"2021-11-16T20:34:44+08:00","permalink":"https://blog.7bao.fun/p/vscode-%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/","title":"VsCode 插件分享"},{"content":"按照国际惯例, 新的博客有一篇 hello 文章, 一来是测试新博客是否运行正常, 二来是记录下为什么要来建个人博客吧.\n其实, 在 2021 年建个人博客应该不太流行了, 现在国内大部分技术类文章基本上都在博客园或者CSDN 这些社区, 我在刚学 PHP 那会, 就租了 3 年的云服务器建个人博客, 学习 Linux 命令和 LNMP 技术栈后来, 但是限于当时懒+技术理解不深, 比如安装环境, 配置域名, 发表的博客带图片的话加载巨慢,因为当时带宽是买的 1M 的, 还要建一个 Mysql 数据库, 还被黑过一次, 当时用的 root@root 这种弱密码并且放开所有权限等等等等, 后来索性就当 Linux 学习机玩了, 文章在偶尔会在知乎上写写.\n最近这种静态博客特别火, 没有服务器, 只需要一个域名(也可以没有), 就可以建一个自己的后花园, 感觉非常不错, 借助 githubAction 甚至都不用自己打包, 平常空闲了学习了什么, 可以写写当做知识的巩固, 毕竟看过不等于会, 讲得出来才叫会, 顺便锻炼一下自己的表达能力, 我觉得这项技能对开发来说尤为重要.\n","date":"2021-11-11T16:17:41+08:00","permalink":"https://blog.7bao.fun/p/helloblog/","title":"HelloBlog"}]