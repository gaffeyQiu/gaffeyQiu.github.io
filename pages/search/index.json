[{"content":"Golang Sync.Mutex 使用及原理 使用 func main() { var mu sync.Mutex var count = 0 var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() mu.Lock() count++ mu.Unlock() }() } wg.Wait() fmt.Println(count) } 实现 首先看 Mutex 到底是什么数据结构\ntype Mutex struct { state int32 sema uint32 } sema 信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒 state uint32 字段被分成了四部分,这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，第三位表示是否进入饥饿模式，剩余的位数代表的是等待此锁的 goroutine 数\nconst ( mutexLocked = 1 \u0026lt;\u0026lt; iota // mutex is locked  mutexWoken //2  mutexStarving //3  mutexWaiterShift = iota //4 } ``` \u0026gt;为了保证锁的公平性，设计上互斥锁有两种状态：正常状态和饥饿状态。 \u0026gt; \u0026gt;`正常模式`下，所有等待锁的goroutine按照FIFO顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。新请求锁的goroutine具有优势：它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。 `如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式`。 \u0026gt; \u0026gt;`饥饿模式`下，锁的所有权将从unlock的gorutine直接交给交给等待队列中的第一个。新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。 \u0026gt; \u0026gt;如果一个等待的goroutine获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。 正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。 #### Mutex.Lock() ```go func (m *Mutex) Lock() { // 如果mutex的state没有被锁，也没有等待/唤醒的goroutine, 锁处于正常状态，那么获得锁，返回.  // 比如锁第一次被goroutine请求时，就是这种状态。或者锁处于空闲的时候，也是这种状态。  if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } // Slow path (outlined so that the fast path can be inlined)  m.lockSlow() } func (m *Mutex) lockSlow() { // 标记本goroutine的等待时间  var waitStartTime int64 // 本goroutine是否已经处于饥饿状态  starving := false // 本goroutine是否已唤醒  awoke := false // 自旋次数  iter := 0 old := m.state for { // 第一个条件：1.mutex已经被锁了；2.不处于饥饿模式(如果时饥饿状态，自旋时没有用的，锁的拥有权直接交给了等待队列的第一个。)  // 尝试自旋的条件：参考runtime_canSpin函数  if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { // 进入这里肯定是普通模式  // 自旋的过程中如果发现state还没有设置woken标识，则设置它的woken标识， 并标记自己为被唤醒。  if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state continue } // 到了这一步， state的状态可能是：  // 1. 锁还没有被释放，锁处于正常状态  // 2. 锁还没有被释放， 锁处于饥饿状态  // 3. 锁已经被释放， 锁处于正常状态  // 4. 锁已经被释放， 锁处于饥饿状态  // 并且本gorutine的 awoke可能是true, 也可能是false (其它goutine已经设置了state的woken标识)  // new 复制 state的当前状态， 用来设置新的状态  // old 是锁当前的状态  new := old // 如果old state状态不是饥饿状态, new state 设置锁， 尝试通过CAS获取锁,  // 如果old state状态是饥饿状态, 则不设置new state的锁，因为饥饿状态下锁直接转给等待队列的第一个.  if old\u0026amp;mutexStarving == 0 { new |= mutexLocked } // 将等待队列的等待者的数量加1  if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1 \u0026lt;\u0026lt; mutexWaiterShift } // 如果当前goroutine已经处于饥饿状态， 并且old state的已被加锁,  // 将new state的状态标记为饥饿状态, 将锁转变为饥饿状态.  if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } // 如果本goroutine已经设置为唤醒状态, 需要清除new state的唤醒标记, 因为本goroutine要么获得了锁，要么进入休眠，  // 总之state的新状态不再是woken状态.  if awoke { // The goroutine has been woken from sleep,  // so we need to reset the flag in either case.  if new\u0026amp;mutexWoken == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken } // 通过CAS设置new state值.  // 注意new的锁标记不一定是true, 也可能只是标记一下锁的state是饥饿状态.  if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 如果old state的状态是未被锁状态，并且锁不处于饥饿状态,  // 那么当前goroutine已经获取了锁的拥有权，返回  if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS  } // If we were already waiting before, queue at the front of the queue.  // 设置并计算本goroutine的等待时间  queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 既然未能获取到锁， 那么就使用sleep原语阻塞本goroutine  // 如果是新来的goroutine,queueLifo=false, 加入到等待队列的尾部，耐心等待  // 如果是唤醒的goroutine, queueLifo=true, 加入到等待队列的头部  runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) // sleep之后，此goroutine被唤醒  // 计算当前goroutine是否已经处于饥饿状态.  starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs // 得到当前的锁状态  old = m.state // 如果当前的state已经是饥饿状态  // 那么锁应该处于Unlock状态，那么应该是锁被直接交给了本goroutine  if old\u0026amp;mutexStarving != 0 { // If this goroutine was woken and mutex is in starvation mode,  // ownership was handed off to us but mutex is in somewhat  // inconsistent state: mutexLocked is not set and we are still  // accounted as waiter. Fix that.  if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 当前goroutine用来设置锁，并将等待的goroutine数减1.  delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) // 如果本goroutine是最后一个等待者，或者它并不处于饥饿状态，  // 那么我们需要把锁的state状态设置为正常模式.  if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { // 退出饥饿模式  delta -= mutexStarving } // 设置新state, 因为已经获得了锁，退出、返回  atomic.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } } Mutex.Unlock() 互斥锁的解锁过程 sync.Mutex.Unlock 与加锁过程相比就很简单，该过程会先使用 AddInt32 函数快速解锁，这时会发生下面的两种情况：\n 如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁； 如果该函数返回的新状态不等于 0，这段代码会调用 sync.Mutex.unlockSlow 方法开始慢速解锁：  sync.Mutex.unlockSlow 方法首先会校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了就会直接抛出异常 sync: unlock of unlocked mutex 中止当前程序。\n在正常情况下会根据当前互斥锁的状态，分别处理正常模式和饥饿模式下的互斥锁：\n  在正常模式下，这段代码会分别处理以下两种情况处理；\n 如果互斥锁不存在等待者或者互斥锁的 mutexLocked、mutexStarving、mutexWoken 状态不都为 0，那么当前方法就可以直接返回，不需要唤醒其他等待者； 如果互斥锁存在等待者，会通过 sync.runtime_Semrelease 唤醒等待者并移交锁的所有权；    在饥饿模式下，上述代码会直接调用 sync.runtime_Semrelease 方法将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；\n  reference https://segmentfault.com/a/1190000023874384\n","date":"2022-02-24T11:19:41+08:00","image":"https://ypy.7bao.fun/img/20220224113610.png","permalink":"https://blog.7bao.fun/p/golang-sync.mutex-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/","title":"Golang Sync.Mutex 使用及原理"},{"content":"Golang Sync.Pool 原理分析  \nGet func (p *Pool) Get() interface{} { // 把当前goroutine固定在当前的P上 \tl, pid := p.pin() x := l.private // 优先从local的private字段取，快速 \tl.private = nil if x == nil { // 从当前的local.shared弹出一个，注意是从head读取并移除 \tx, _ = l.shared.popHead() if x == nil { // 如果没有，则去偷一个 \tx = p.getSlow(pid) } } runtime_procUnpin() // 如果没有获取到，尝试使用New函数生成一个新的 \tif x == nil \u0026amp;\u0026amp; p.New != nil { x = p.New() } return x }  首先，从本地的 private 字段中获取可用元素，因为没有锁，获取元素的过程会非常快 如果没有获取到，就尝试从本地的 shared 获取一个 如果还没有，会使用 getSlow 方法去其它的 shared 中“偷”一个 最后，如果没有获取到，就尝试使用 New 函数创建一个新的。  Put func (p *Pool) Put(x interface{}) { if x == nil { // nil值直接丢弃 \treturn } l, _ := p.pin() if l.private == nil { // 如果本地private没有值，直接设置这个值即可 \tl.private = x x = nil } if x != nil { // 否则加入到本地队列中 \tl.shared.pushHead(x) } runtime_procUnpin() } Put 的逻辑相对简单，优先设置本地 private，如果 private 字段已经有值了，那么就把此元素 push 到本地队列中\n注意  sync.Pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象 它池化的对象可能会被垃圾回收掉，这对于数据库长连接等场景是不合适的 如果做 buffer 池，由于 buffer 可能会被业务使用中扩容，放回池子的时候需要判断一下大小和清除里面保存的数据。  ","date":"2022-02-24T11:19:41+08:00","image":"https://ypy.7bao.fun/img/20220224113735.png","permalink":"https://blog.7bao.fun/p/golang-sync.pool-%E5%8E%9F%E7%90%86/","title":"Golang Sync.Pool 原理"},{"content":"Golang Sync.WaitGroup 使用及原理 使用 func main() { var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() fmt.Println(\u0026#34;Hello WaitGroup!\u0026#34;) }() } wg.Wait() } 实现 首先看 waitgroup 到底是什么数据结构\ntype WaitGroup struct { noCopy noCopy state1 [3]uint32 } nocopy 避免这个结构体被复制的一个技巧，可以告诉go vet工具违反了复制使用的规则 state1 [3]uint32 字段中包含了 waitgroup 的所有状态信息, 根据标准库上自带的注释简单翻译是：state1 由 12 个字节组成，其中将8字节看作64位值，其中高32位存放的是 counter 计数器, 代表目前还未完成的 goroutine个数，低32位存放的是 waiter 计数器, 可以理解成下面这个结构体\ntype WaitGroup struct { // 代表目前尚未完成的个数 \t// WaitGroup.Add(n) 将会导致 counter += n \t// WaitGroup.Done() 将导致 counter-- \tcounter uint32 // 目前已调用 WaitGroup.Wait 的 goroutine 的个数 \twaiter uint32 // 对应于 golang 中 runtime 内部的信号量的实现 \t// runtime_Semacquire 表示增加一个信号量，并挂起当前 goroutine \t// runtime_Semrelease 表示减少一个信号量，并唤醒 sema 上其中一个正在等待的 goroutine \tsema uint32 } 整个使用流程为：\n 当调用 WaitGroup.Add(n) 时，counter 将会自增: counter += n 当调用 WaitGroup.Wait() 时，会将 waiter++。同时调用 runtime_Semacquire(semap), 增加信号量，并挂起当前 goroutine。 当调用 WaitGroup.Done() 时，将会 counter--。如果自减后的 counter 等于 0，说明 WaitGroup 的等待过程已经结束，则需要调用 runtime_Semrelease 释放信号量，唤醒正在 WaitGroup.Wait 的 goroutine。  源码中是如何拆分 state 字段的\nfunc (wg *WaitGroup) state() (statep *uint64, semap *uint32) { if uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0 { // 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量 \treturn (*uint64)(unsafe.Pointer(\u0026amp;wg.state1)), \u0026amp;wg.state1[2] } else { // 如果地址是32bit对齐的，数组后两个元素用来做state  // 它可以用来做64bit的原子操作，第一个元素32bit用来做信号量  return (*uint64)(unsafe.Pointer(\u0026amp;wg.state1[1])), \u0026amp;wg.state1[0] } } 由于我们能使用到的就是 waitgroup.Add(), waitgroup.Done(), waitgroup.Wait() 这三个方法，就按这三个方法分析\nAdd(), Done() Add 方法主要操作的是 state 的计数部分。你可以为计数值增加一个 delta 值，内部通过原子操作把这个值加到计数值上。需要注意的是，这个 delta 也可以是个负数，相当于为计数值减去一个值，Done 方法内部其实就是通过 Add(-1) 实现的。\nfunc (wg *WaitGroup) Add(delta int) { // 获取拆开后的 state 字段  statep, semap := wg.state() ... ... ... // 在刚刚说的 int64 的高32位上加伤传进来的 delta 的值， 这一步是原子操作  state := atomic.AddUint64(statep, uint64(delta)\u0026lt;\u0026lt;32) // 加好后，获取 counter 也就是 v， 和 waiter 也就是 w 的值  // 此时 int64 变为两个 int32  v := int32(state \u0026gt;\u0026gt; 32) w := uint32(state) // 如果 v 变为负数了，程序异常  if v \u0026lt; 0 { panic(\u0026#34;sync: negative WaitGroup counter\u0026#34;) } // 在 wait 没结束之前， 不允许调用 Add 方法  if w != 0 \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // 调用 add() 之后, 还有正在执行的 goroutine 或者 waiter 等于 0， 正常返回  if v \u0026gt; 0 || w == 0 { return } // 下面就是非正常返回， 理解到的就是 v 已经等于 0 了，执行释放操作  // 首先就是将 counter 和 waiter 全部重置为 0  *statep = 0 // 然后循环调用还在等待的 waiter， 释放信号量  for ; w != 0; w-- { runtime_Semrelease(semap, false, 0) } } wait() Wait 方法的实现逻辑是：不断检查 state 的值。如果其中的计数值变为了 0，那么说明所有的任务已完成，调用者不必再等待，直接返回。如果计数值大于 0，说明此时还有任务没完成，那么调用者就变成了等待者，需要加入 waiter 队列，并且阻塞住自己。\nfunc (wg *WaitGroup) Wait() { // 获取信号量和两个计数值  statep, semap := wg.state() // 不停的循环检查 counter 和 waiter  for { // 先原子性的取出 counter 和 waiter  state := atomic.LoadUint64(statep) v := int32(state \u0026gt;\u0026gt; 32) w := uint32(state) if v == 0 { // counter 已经没有了，函数可以返回  return } // 将 waiter 数 + 1  if atomic.CompareAndSwapUint64(statep, state, state+1) { // 放到信号量队列, 并且阻塞住自己  runtime_Semacquire(semap) // 如果被唤醒，检查 两个计数是否已经为0 了， 如果不为0 ，则触发恐慌  if *statep != 0 { panic(\u0026#34;sync: WaitGroup is reused before previous Wait has returned\u0026#34;) } // 函数返回  return } } } 总结  保证计数器不能为负值 保证 Add() 方法全部调用完成之后再调用 Wait() waitgroup 可以重复使用 atomic 原子操作代替锁, 提高并发性 合并两个 int32 为一个 int64 提高读取存入数据性能 对于不希望被复制的结构体， 可以使用 noCopy 字段  reference https://www.cyhone.com/articles/golang-waitgroup/ https://time.geekbang.org/column/intro/100061801?tab=catalog\n","date":"2022-02-24T11:17:41+08:00","image":"https://ypy.7bao.fun/img/20220224113450.png","permalink":"https://blog.7bao.fun/p/golang-sync.waitgroup-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/","title":"Golang Sync.WaitGroup 使用及原理"},{"content":"交互式系统在个人计算机，服务器和其他类系统中都是常用的\n1. 轮转调度（round robin） 一种最古老，最简单，最公平且使用最广的算法。 每个进程被分配一个时间段，称为时间片（quantum），如果在时间片结束时该进程还在运行，则剥夺CPU并分配给另一个进程。如果该进程在时间片内阻塞或结束，则CPU立即切换。\n 时间片通常设置为 20 ～ 50ms，因为太短会频繁上下文切换，太长可能导致程序响应变长\n 2. 优先级调度 为每个进程赋予一个优先级，允许优先级高的进程先执行\n3. 多级队列（CTSS） 先设立优先级类，最高优先级类的进程运行1个时间片，次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推，当一个进程用完分配的时间片后，它被移到下一类，如果是遇到需要交互输入的进程，为了避免等待用户输入的时候，被调度算法安排到比较底的优先级中，按下回车键，就会把该进程提高到最高优先级类中。\n4. 最短进程优先 根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。\n5. 保证调度 由于各个进程实际获得的CPU时间是已知的，所以可以计算出真正获得CPU时间和应该获得CPU时间的比例，比率为0.5则说明当前进程仅获得了应得时间的一半，而 2.0 则说明该进程获得了双倍的应得时间，于是算法随后转向比率最低的进程\n6. 彩票调度 为进程提供各种系统资源的彩票，一旦要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程可以获得资源。同时可以给更重要的进程分配更多的彩票，以便增加它们获胜的机会。\n7. 公平分享调度 假设用户1启动了9个进程，而用户2只有一个进程，使用轮转或相同优先级的算法， 用户1能获得90%的CPU时间，而用户2只能得到10%的CPU时间\n为了避免这一情况，某些系统在调度处理之前考虑谁拥有进程这一因素。\n线程的调度 用户级线程 内核不知道线程的存在，假设A，B进程都运行了若干个线程， 那么CPU运行进程A时，此时进程A中的线程A1，A2，A3 按照顺序依次执行直到当前时间片结束，然后切换到进程B执行。其中线程执行的顺序则有进程保证。\n内核级线程 内核会从AB两个进程中选择一个特定的线程来执行，它不用考虑该线程属于哪个进程（如果有必要，也可以考虑），对被选择的进程赋予一个时间片，当超过时间片时候，强制挂起该线程。这样执行顺序可能是 A1，B1，A2，B2\n区别 用户级线程和内核级线程性能相差很大，用户级线程切换需要少量的机器指令，而内核线程切换则需要上下文切换，修改内存映象，使高速缓存失效，这导致了若干数量级的延迟。 另一方面，一旦线程阻塞在一个I/O上，不需要像用户级线程中将整个进程挂起。 另一个重要因素是用户级线程可以使用专门的调度程序，而内核级线程则无法为某个进程定制调度策略。所以用户级线程性能会更好。\n","date":"2022-02-24T10:00:41+08:00","image":"https://ypy.7bao.fun/img/20220224114114.png","permalink":"https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/","title":"进程调度"},{"content":"进程间通信 （Inter Process Communication） 竞争条件（race condition） 前提 书中举了一个脱机打印程序的例子，当一个进程需要打印一个文件，它将需要打印的文件名放在一个特殊的目录下（脱机目录），另一个进程则周期性的检查是否有文件需要打印，如果有就打印这个文件并将文件名从这个目录下删掉。\n假设这个目录下有很多格子，每个格子可以放一个文件名，还有两个共享变量 in 和 out out 指向下一个要打印的文件名，in 指向目录中下一个空闲的格子。这两个变量能同时被这两个进程访问到。\n场景   在某一时刻， 4～6 号格子被需要打印的文件名占用。 在同一时刻，进程A 和 进程B 都决定要打印一个文件，会发生的可能情况：\nA 读到 in 的值为 7，然后将 7 存在自己进程的一个变量中 next_free_slot, 此时发生一次时钟中断，CPU 切换到 B，进程 B 也读到 in 的值为 7，同样存放到自己进程变量 next_free_slot 中，结果这两个进程都认为下一个可用格子为 7， B 接着运行，它将需要打印的文件名写入 7 号格子中，并更新 in 的值为 8，然后进程B执行结束，换到 进程A 从上次中断的地方执行， A 检查自己的 next_free_slot 为 7，于是把文件名写入到 7 号格子中，修改 in 的值为 8， 出现的结果就是 进程B 需要打印的文件名被覆盖掉， 导致进程B需要打印的文件不会被打印机打印， 程序也不会发生任何错误。\n类似这样的情况， 称为 竞争条件（race condition）\n临界区 凡涉及共享内存、共享文件以及共享任何资源的情况都会引发与前面类似的错误， 要避 免这种错误 。 我们把对共享内存进行访问的程序片段称作 临界区域（critical region） 或 临界区（critical section）。\n对于一个好的解决方案，需要满足以下4个条件： 1.任何两个进程不能同时处于其临界区. 2.不应对CPU的速度和数量做任何假设。 3.临界区外运行的进程不得阻塞其他进程。 4.不得使进程无限期等待进入临界区。\n \n忙等待的互斥 1. 屏蔽中断 在单核处理器中，最简单直接的方法是程序进入临界区之前屏蔽掉所有中断，这样能保证程序在临界区内的操作不会被其他进程介入，然后离开临界区之后再恢复中断。 缺点： 把屏蔽中断权利交给用户进程是不明智的，假如用户进程屏蔽中断之后不再打开中断，系统会因此而终止。\n2. 锁变量 假设有一个共享变量A，初始值为 0， 当某个程序想进入临界区之前，获取到 A 的值为 0，代表可以进入临界区，修改 A 为 1，然后执行临界区操作，离开临界区再将 A 的值改为 0， 如果其他进程获取到 A 的值为1的时候，则等待 A = 0 之后再进入临界区。 缺点： 和脱机打印程序的例子一样，有可能两个程序读到相同的值。\n3. 严格轮换法 定义一个整形变量 turn，用于记录轮到哪个进程进入临界区，开始时由于 turn 初始值为0，所以进程0 可以进入临界区，进程1发现 turn 为0，所以不停循环检查 turn 的值何时为 1。\n 这种不停测试变量直到某个值出现，成为忙等待，会浪费CPU时间，应该避免，只有认为等待时间非常短的情况下才可以使用，称为自旋锁（spin lock）\n  \n当进程0结束了非临界区的操作并回到最开始的循环，但是，这个时候它还不能进入临界区，因为进程1还在执行非临界区的操作，进程0只有等待进程1把 turn 的值改为0，这说明，在一个进程比另一个进程慢的情况下，轮流进入临界区并不是一个好办法。\n4. Peterson 解法   进入临界区之前，每个进程调用 enter_region() 方法传入自己的进程号 0 或者1，该函数最后一段代码会进行忙等待，直到允许进入临界区，然后调用 leave_region() 方法离开临界区。 举一个例子：进程0和1都想进入临界区，他们同时调用了enter_region()， 现在全局变量 interested[0] = TRUE， turn = 0 ，然后被稍微后进入的进程1覆盖了这些变量 interested[1] = TRUE， turn = 1， 此时都执行到 while 语句， turn == process \u0026amp;\u0026amp; interested[other] == TRUE 此时进程1刚好满足这条语句，进入空循环，也就是忙等待， 进程0得以进入临界区，进程 0 执行完毕后将 interested[0] = FALSE, 然后进程1的这条判断不成立 interested[other] == TRUE, 进程1则可以正常进入临界区。 缺点：有忙等待调用\n5.TSL指令 TSL RX, LOCK 这是一种硬件支持的方案, 称为 测试并加锁 ， 它是将一个字读到寄存器 RX 中，然后在该内存地址上存一个非0值，执行 TSL 指令的 CPU将锁住内存总线，禁止其他CPU在本指令结束之前访问内存 ![[Pasted image 20220222180533.png]]\n同步原语 前面的解法都会有忙等待问题，浪费了大量的 CPU 时间。 所以同步原语会阻塞进程，而不是忙等待。\n信号量（semaphore） 为了确保信号量能正确工作， 通常将 down 和 up（经常称为 P 和 V）作为系统调用实现，操作系统只需在执行信号量检测，更新信号量的时候屏蔽全部中断即可，而且由于这些动作只需要几条指令，不会有忙等待的副作用（操作系统也是借用 TSL 等硬件支持的指令来完成）\n互斥量（Mutex） 互斥量是简化版本的信号量，它不需要计数能力，所以只需要一个二进制位表示。互斥量仅仅适用于管理共享资源或一小段代码。 当需要访问临界区资源时候，调用 mutex_lock , 离开临界区使用 mutex_unlock, 当其他进程同时想进入临界区调用 lock 方法时，会被阻塞，它将调用 thread_yield 将 CPU 放弃给另一个线程，直到再次轮到自己执行，才会检查锁。 由于 thread_yield 和 mutex 的 lock 和 unlock 方法都是用户空间中进行， 不需要进行系统调用，所以运行非常快。\n管程（monitor） 和 条件变量（condition） 引入了管程是为了将对共享资源的所有访问及其所需要的同步操作集中并封装起来。 管程相当于一个隔离区，它把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程，从而需要确保进程之间互斥。 但在管程中仅仅有互斥操作是不够用的。进程可能需要等待某个条件Cond为真才能继续执行。如果采用忙等待方式：\nwhile not (Cond) do {} 在单处理器情况下，将会导致所有其它进程都无法进入临界区使得该条件Cond为真，该管程的执行将会发生死锁。 为此，可引入条件变量（Condition Variables，简称CV）。一个条件变量CV可理解为一个进程的等待队列，队列中的进程正等待某个条件Cond变为真。每个条件变量关联着一个条件，如果条件Cond不为真，则进程需要等待，如果条件Cond为真，则进程可以进一步在管程中执行。需要注意当一个进程等待一个条件变量CV（即等待Cond为真），该进程需要退出管程，这样才能让其它进程可以进入该管程执行，并进行相关操作，比如设置条件Cond为真，改变条件变量的状态，并唤醒等待在此条件变量CV上的进程。因此对条件变量CV有两种主要操作：\n wait_cv： 被一个进程调用，以等待断言Pc被满足后该进程可恢复执行. 进程挂在该条件变量上等待时，不被认为是占用了管程。 signal_cv：被一个进程调用，以指出断言Pc现在为真，从而可以唤醒等待断言Pc被满足的进程继续执行。  消息传递 屏障 （barrier） 规定当一个进程到达屏障时， 它就被屏障阻拦，直到所有进程都到达该屏障为止。屏障可用于一组进程同步  \n避免锁：读-复制-更新RCU(Read-Copy Update) 最快的锁就是没有锁。 RCU是 Linux 中比较重要的一种同步机制。随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作\n","date":"2022-02-24T10:00:41+08:00","image":"https://ypy.7bao.fun/img/20220224103519.png","permalink":"https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1inter-process-communication/","title":"进程间通信（Inter Process Communication）"},{"content":"[实验] ucore 环境准备 环境准备 1. 准备一台装有 ubuntu 操作系统的机器 建议是在虚拟机里面安装一个 ubuntu， 避免对自己机器的影响， 我安装的是当时最新版本ubuntu桌面端\n https://ypy.7bao.fun/img/20211222204823.png \nps：小豹子挺可爱的\n2. 安装环境  gcc: 编译 c++ make: 自动编译或测试代码 gdb: 调试代码 cgdb: 字符方式调试代码 qemu: 调试内核，实验中搭配 cgdb 使用 git: 获取实验所需代码 vscode: 编写代码 vim: 偶尔也会在终端用 vim 查看代码  3. 实验资料 https://github.com/chyyuu/os_course_info\nIntroduction\nIntroduction\n4. 获取代码 根据实验资料查到项目地址，非常友好的开源了，没有放在清华的内网。\ngit clone \u0026lt;https://github.com/chyyuu/os_kernel_lab.git 这样获取到的代码默认是 rust 语言实现的，目前我学习的是 c 语言实现，所以切换到 master 分支 （后续实验完成了希望能用 rust 也实现一遍)\ngit checkout master 5.验证环境 可以参考视频 学堂在线 2.7 演示实验操作过程\n# 进入代码 lab1 的答案目录 cd os_kernel_lab/labcodes_answer/lab1_result # 清理上次构建的产物（首次可以不用清理） make clean # 启动 qemu make qemu  https://ypy.7bao.fun/img/20211222210237.png \n能成功看到不停的有 ticks 输出即可\n6. 如何 Debug   使用 cgdb 调试 在每个 lab 的目录下执行 make debug, 即可弹出 debug 界面\n https://ypy.7bao.fun/img/20211222222409.png \n  使用 vscode 调试 效果上比 cgdb 强了不少，可惜不能调试 bootmain.c\n需要预先填好下面的 vscode debug 配置文件\nlaunch.json 文件\n{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: \u0026lt;https://go.microsoft.com/fwlink/?linkid=830387\u0026gt; \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc - 生成和调试活动文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;miDebuggerServerAddress\u0026#34;: \u0026#34;localhost:1234\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/bin/kernel\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;make-gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/usr/bin/gdb\u0026#34; } ] } tasks.json 文件\n{ \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;make-gdb\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;make\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;gdb\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;isBackground\u0026#34;: true, \u0026#34;problemMatcher\u0026#34;: { \u0026#34;pattern\u0026#34;: { \u0026#34;regexp\u0026#34;: \u0026#34;.\u0026#34; }, \u0026#34;background\u0026#34;: { \u0026#34;activeOnStart\u0026#34;: true, \u0026#34;beginsPattern\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;endsPattern\u0026#34;: \u0026#34;.\u0026#34; }, }, } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 点击 vscode 的 debug 按钮， 会出现如图所示的效果\n https://ypy.7bao.fun/img/20211222222255.png \n  ","date":"2021-12-22T22:38:41+08:00","image":"https://ypy.7bao.fun/img/xps-EzYq1HOl5_8-unsplash.jpg","permalink":"https://blog.7bao.fun/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-ucore-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/","title":"[操作系统实验] ucore 环境准备"},{"content":"数据库是如何工作的?  数据在磁盘或内存中以什么格式保存？ 它什么时候从内存移动到磁盘？//todo 为什么一张表只能有一个主键？ 事务如何回滚？ 索引是如何格式化的？//todo 何时以及如何进行全表扫描？ 准备好的语句保存格式是什么？  简而言之，数据库是如何工作的？\n我正在用 C 从头开始构建一个 sqlite 的副本，以便理解，我将在进行的过程中记录我的过程\n目录  Part1 -  reference  https://cstack.github.io/db_tutorial\n ","date":"2021-12-17T16:08:41+08:00","image":"https://ypy.7bao.fun/img/jonathan-arbely-477E0cXoc1c-unsplash.jpeg","permalink":"https://blog.7bao.fun/p/%E7%BF%BB%E8%AF%91how-does-a-database-work/","title":"[翻译]How Does a Database Work?"},{"content":"显示函数的参数 (cmd + p)   实现接口 (ctrl + i) (cmd + n)  \n生成测试 (cmd + shift + t) (cmd + n)   在打开的文件之间导航 (ctrl + tab)     最近的文件 (cmd + e)   查看结构体窗口 (cmd + F12)   调用层次接口 (ctrl + alt + h)   显示引用 (alt + F7)   历史剪贴板 (cmd + shift + v)   打开/关闭终端 (alt + F12) 跳转到定义或引用 (cmd + b) 前进/后退 (cmd + [) (cmd + ]) 自动填充结构体 (alt + enter)   快速显示定义 (cmd + y)  \n","date":"2021-12-03T13:17:01+08:00","image":"https://ypy.7bao.fun/img/20211204191404.png","permalink":"https://blog.7bao.fun/p/goland-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"Goland 使用技巧"},{"content":"在做 API 接口开发时, 一般会统一 API 返回格式, 例如\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;data\u0026#34;: { //xxxxx  //xxxxx  }, \u0026#34;message\u0026#34;: \u0026#34;OK\u0026#34; } 在后端代码定义中, 也会定义一个结构体来对应这种结构, 并且, 由于 data 字段里的数据是未知的(与具体业务相关), 所以会定义一个 interface 来接收\ntype ApiResponse struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;message\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } 然后根据具体业务响应, 向 data 传入不同的模型, 比如\nc.JSON(200, ApiResponse{200, \u0026#34;OK\u0026#34;, User}) 但是这里有个很大的问题, swagger 文档中, 这个接口的返回值该怎么定义?\n// @Summary 获取用户信息 // ... // ... // @Success 200 {object} ApiResponse \u0026#34;ok\u0026#34; func GetUser(c *gin.Context) { xxxx } 如果这样定义, 生成的文档会是下面这样, 因为原始 ApiResponse 就是一个 interface, 所以是空  \n但是这样的文档写出来就没什么意义了, 大多数的做法就是会专门定义一个用于 swagger 显示的结构体, 类似这样\ntype UserResponse struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;message\u0026#34;` Data User `json:\u0026#34;data\u0026#34;` } 虽然效果有了, 但是这样无疑增加了巨多的工作量, 让写代码变得索然无味, 翻看 swaggo/swag 的文档, 发现支持了替换字段的方式, 可以完美解决现在这种问题, 效果如下  \n下面是测试代码\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // @title Swagger Example API // @version 1.0 // @description This is a sample server Petstore server. // @termsOfService http://swagger.io/terms/  // @contact.name API Support // @contact.url http://www.swagger.io/support // @contact.email support@swagger.io  // @license.name Apache 2.0 // @license.url http://www.apache.org/licenses/LICENSE-2.0.html  // @host petstore.swagger.io // @BasePath /v2 func main() { r := gin.New() r.GET(\u0026#34;/user/:id\u0026#34;, GetUser) } // @Summary 获取用户信息 // @Description get User by ID // @ID get-user-by-id // @Accept json // @Produce json // @Param id path int true \u0026#34;用户 id\u0026#34; // @Success 200 {object} ApiResponse{data=User} \u0026#34;ok\u0026#34; // @Router /user/{id} [get] func GetUser(c *gin.Context) { resp := new(ApiResponse) paramID := c.Param(\u0026#34;id\u0026#34;) uid, _ := strconv.Atoi(paramID) user := User{ ID: uid, Name: \u0026#34;张三\u0026#34;, } resp.Code = 200 resp.Msg = \u0026#34;OK\u0026#34; resp.Data = user c.JSON(http.StatusOK, resp) } type User struct { ID int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } type ApiResponse struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;message\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } ","date":"2021-12-01T19:17:41+08:00","image":"https://ypy.7bao.fun/img/20211201201550.png","permalink":"https://blog.7bao.fun/p/gin-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B-swagger-%E6%96%87%E6%A1%A3/","title":"Gin 如何动态生成模型 swagger 文档"},{"content":"在查看或者编写 k8s API 的时候, 经常会看到四个术语 groups versions kinds resources 其中大多数以组合的形式出现, 分别为 GVK GVR, 这两个术语很容易弄混, 接下来讲讲他们的区别.\nGroup 和 Version Group 和 Version 很好理解, 在 k8s 用 yaml 清单部署过服务的都应该看到过这个字段\napiVersion:apps/v1kind:xxxmetadata:上面例子中, apps 就是 group, version 是 v1, 每个 group 可以包含多个 version, 这样的关系可以随着时间的推移, 创建多个不同 version 来兼容更多的 api 改动\n特殊的, 有的资源没有 group, 只有 version, 例如 pod, 这类被称为核心资源组  \n 其中 Alpha 是内测版本, 一般不建议使用, 如 v1alpha1, Beta 是经过测试的相对稳定版, 如 v1beta1, Stable 是正式发布版 如 v1, v2\n Kind 这个字段第一次接触应该是在 yaml 清单, 常见的有 pod, deployment, service 等, 它结合 apiVersion 能确定一个具体的 API 类型, 比如下面的 yaml 清单能定位到一种 API 类型\napiVersion:apps/v1kind:DaemonSetmetadata:name:node-exporter但是有了这个 apiVersion 和 kind , kubectl 如何转化成 http rest 请求发送到 apiServer 的呢? 这就需要用到 Resource 了\nResources 有了 Resource , 搭配 group 和 version, 就能很轻易的知道对应的资源 rest url, 比如 deployment, 它的 apiVersion 是 apps/v1, 就可以查询集群中某个命名空间下的 deployment 列表.\nGET /apis/apps/v1/deployments // 也可以限定命名空间查询 /apis/apps/v1/namespaces/${namespace}/deployments { \u0026#34;kind\u0026#34;: \u0026#34;DeploymentList\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;apps/v1\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/apps/v1/namespaces/tke/deployments\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;4819273\u0026#34; }, \u0026#34;items\u0026#34;: [ { \u0026#34;metadata\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;tke-auth-api\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;tke\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/apps/v1/namespaces/tke/deployments/tke-auth-api\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;28979433-72d2-40d0-8555-038bdd8b95ca\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;1344\u0026#34;, \u0026#34;generation\u0026#34;: 1, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2021-11-22T08:13:44Z\u0026#34;, \u0026#34;labels\u0026#34;: { \u0026#34;app\u0026#34;: \u0026#34;tke-auth-api\u0026#34; }, \u0026#34;annotations\u0026#34;: { \u0026#34;deployment.kubernetes.io/revision\u0026#34;: \u0026#34;1\u0026#34; }, ... ... 可以发现, resouce 和 kind 区别并不大, 拿上面的例子来说, kind 是 deployment, resource 也是 deployment, 但是光知道 GVK, 只能知道是一个什么类型的 API, 但是知道 GVR, 就能知道具体的资源, 有点类似于面向对象的 类 和 对象 的区别, Kind 类似 User 类, 那么 new User(张三) 就是对应的 Resource 了\n 通常情况下 Kind 和 Resource 是一一对应的, Scale Kind 可能对应很多 Resources：deployments/scale 或者 replicasets/scale, 而且 Resource 始终是小写形式，并且通常情况下是 Kind 的小写\n GVK GVR 互转 编码过程中, 如果遇到这两种类型, 可以通过 RESTMapper 进行互相转换\ntype RESTMapper interface { // KindFor takes a partial resource and returns the single match. Returns an error if there are multiple matches \tKindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error) // KindsFor takes a partial resource and returns the list of potential kinds in priority order \tKindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error) // ResourceFor takes a partial resource and returns the single match. Returns an error if there are multiple matches \tResourceFor(input schema.GroupVersionResource) (schema.GroupVersionResource, error) // ResourcesFor takes a partial resource and returns the list of potential resource in priority order \tResourcesFor(input schema.GroupVersionResource) ([]schema.GroupVersionResource, error) // RESTMapping identifies a preferred resource mapping for the provided group kind. \tRESTMapping(gk schema.GroupKind, versions ...string) (*RESTMapping, error) // RESTMappings returns all resource mappings for the provided group kind if no \t// version search is provided. Otherwise identifies a preferred resource mapping for \t// the provided version(s). \tRESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error) ResourceSingularizer(resource string) (singular string, err error) } ","date":"2021-12-01T11:37:00+08:00","image":"https://ypy.7bao.fun/img/20211201134543.png","permalink":"https://blog.7bao.fun/p/gvk-%E5%92%8C-gvr-%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"GVK 和 GVR 的区别"},{"content":"vscode 配置或快捷键  cmd + j 打开或关闭终端 F12 或 ctrl + ] 跳转到函数定义处 gh 显示鼠标 hover 在当前位置时提示的信息 ctrl + i 前进 ctrl + o 后退 alt + F8 光标定位到当前页面问题代码 cmd + . 快速修复问题代码 ctrl + Enter 水平分屏方式打开文件  vscode json 配置项  Go 语言静态检查配置  staticcheck是针对go的静态检查工具，文档地址 在 setting.json 中过滤掉对应的编号(例如过滤掉 ST1020 和 所有 S1 开头的规则) \u0026#34;go.lintFlags\u0026#34;: [ \u0026#34;-checks\u0026#34;, \u0026#34;all,-ST1020,-S1*\u0026#34; ]     vim 自身按键  {number} + w 向前移动 N 个单词 {number} + b 向后移动 N 个单词 % 跳转到匹配的括号 ctrl + ] + gd 跳转到函数定义处 gh 显示鼠标 hover 在当前位置时提示的信息 {number} + f + {char} 向右移动到第 N 个指定字符处 zt/zz/zb 光标跳转到屏幕的顶/中/底部 {number} + ctrl + E 向上滚屏 {number} + ctrl + Y 向上滚屏 ctrl + c 退出插入模式  vim 插件快捷键  ds\u0026quot; 删除 \u0026ldquo;abc\u0026rdquo; 的双引号 cs\u0026quot;' 替换 \u0026ldquo;abc\u0026rdquo; 为 \u0026lsquo;abc\u0026rsquo; ysw\u0026quot; 添加\u0026quot;\u0026ldquo;给一个单词 S\u0026quot; 选中 abc 的情况下, 给 abc 加上双引号  ","date":"2021-11-17T15:17:01+08:00","permalink":"https://blog.7bao.fun/p/vscode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"VsCode 使用技巧"},{"content":"主题类 1. Material Icon Theme  功能说明: 可以给文件夹和文件自动添加 icon, 这个是同类插件中看起来最舒服的 使用说明: 安装完成后即可使用  image.png   2. One Dark Pro  功能说明: vscode 使用人数比较多的主题 使用说明: 安装完成后即可使用\n image.png   3. Darcula IntelliJ Theme  功能说明: 如果你习惯 jetbrains 家的 IDE, 这个 vscode 主题绝对适合你 使用说明: 安装完成后即可使用  image.png   效率类 1. Git Graph  功能说明: 一款 git 可视化插件, 非常好看而且实用 使用说明: 安装完成后即可使用    2. Docker  功能说明: Dockerfile 提示, 管理本地 docker 服务 安装完成后即可使用     \u0026hellip;不定期补充\n ","date":"2021-11-16T20:34:44+08:00","permalink":"https://blog.7bao.fun/p/vscode-%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/","title":"VsCode 插件分享"},{"content":"按照国际惯例, 新的博客有一篇 hello 文章, 一来是测试新博客是否运行正常, 二来是记录下为什么要来建个人博客吧.\n其实, 在 2021 年建个人博客应该不太流行了, 现在国内大部分技术类文章基本上都在博客园或者CSDN 这些社区, 我在刚学 PHP 那会, 就租了 3 年的云服务器建个人博客, 学习 Linux 命令和 LNMP 技术栈后来, 但是限于当时懒+技术理解不深, 比如安装环境, 配置域名, 发表的博客带图片的话加载巨慢,因为当时带宽是买的 1M 的, 还要建一个 Mysql 数据库, 还被黑过一次, 当时用的 root@root 这种弱密码并且放开所有权限等等等等, 后来索性就当 Linux 学习机玩了, 文章在偶尔会在知乎上写写.\n最近这种静态博客特别火, 没有服务器, 只需要一个域名(也可以没有), 就可以建一个自己的后花园, 感觉非常不错, 借助 githubAction 甚至都不用自己打包, 平常空闲了学习了什么, 可以写写当做知识的巩固, 毕竟看过不等于会, 讲得出来才叫会, 顺便锻炼一下自己的表达能力, 我觉得这项技能对开发来说尤为重要.\n","date":"2021-11-11T16:17:41+08:00","permalink":"https://blog.7bao.fun/p/helloblog/","title":"HelloBlog"}]