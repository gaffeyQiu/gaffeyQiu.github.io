<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OS on gaffey的开发日志</title>
    <link>https://blog.7bao.fun/tags/os/</link>
    <description>Recent content in OS on gaffey的开发日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Feb 2022 10:00:41 +0800</lastBuildDate><atom:link href="https://blog.7bao.fun/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>进程调度</title>
      <link>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Thu, 24 Feb 2022 10:00:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid>
      <description>交互式系统在个人计算机，服务器和其他类系统中都是常用的
1. 轮转调度（round robin） 一种最古老，最简单，最公平且使用最广的算法。 每个进程被分配一个时间段，称为时间片（quantum），如果在时间片结束时该进程还在运行，则剥夺CPU并分配给另一个进程。如果该进程在时间片内阻塞或结束，则CPU立即切换。
 时间片通常设置为 20 ～ 50ms，因为太短会频繁上下文切换，太长可能导致程序响应变长
 2. 优先级调度 为每个进程赋予一个优先级，允许优先级高的进程先执行
3. 多级队列（CTSS） 先设立优先级类，最高优先级类的进程运行1个时间片，次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推，当一个进程用完分配的时间片后，它被移到下一类，如果是遇到需要交互输入的进程，为了避免等待用户输入的时候，被调度算法安排到比较底的优先级中，按下回车键，就会把该进程提高到最高优先级类中。
4. 最短进程优先 根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。
5. 保证调度 由于各个进程实际获得的CPU时间是已知的，所以可以计算出真正获得CPU时间和应该获得CPU时间的比例，比率为0.5则说明当前进程仅获得了应得时间的一半，而 2.0 则说明该进程获得了双倍的应得时间，于是算法随后转向比率最低的进程
6. 彩票调度 为进程提供各种系统资源的彩票，一旦要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程可以获得资源。同时可以给更重要的进程分配更多的彩票，以便增加它们获胜的机会。
7. 公平分享调度 假设用户1启动了9个进程，而用户2只有一个进程，使用轮转或相同优先级的算法， 用户1能获得90%的CPU时间，而用户2只能得到10%的CPU时间
为了避免这一情况，某些系统在调度处理之前考虑谁拥有进程这一因素。
线程的调度 用户级线程 内核不知道线程的存在，假设A，B进程都运行了若干个线程， 那么CPU运行进程A时，此时进程A中的线程A1，A2，A3 按照顺序依次执行直到当前时间片结束，然后切换到进程B执行。其中线程执行的顺序则有进程保证。
内核级线程 内核会从AB两个进程中选择一个特定的线程来执行，它不用考虑该线程属于哪个进程（如果有必要，也可以考虑），对被选择的进程赋予一个时间片，当超过时间片时候，强制挂起该线程。这样执行顺序可能是 A1，B1，A2，B2
区别 用户级线程和内核级线程性能相差很大，用户级线程切换需要少量的机器指令，而内核线程切换则需要上下文切换，修改内存映象，使高速缓存失效，这导致了若干数量级的延迟。 另一方面，一旦线程阻塞在一个I/O上，不需要像用户级线程中将整个进程挂起。 另一个重要因素是用户级线程可以使用专门的调度程序，而内核级线程则无法为某个进程定制调度策略。所以用户级线程性能会更好。</description>
    </item>
    
    <item>
      <title>进程间通信（Inter Process Communication）</title>
      <link>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1inter-process-communication/</link>
      <pubDate>Thu, 24 Feb 2022 10:00:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1inter-process-communication/</guid>
      <description>进程间通信 （Inter Process Communication） 竞争条件（race condition） 前提 书中举了一个脱机打印程序的例子，当一个进程需要打印一个文件，它将需要打印的文件名放在一个特殊的目录下（脱机目录），另一个进程则周期性的检查是否有文件需要打印，如果有就打印这个文件并将文件名从这个目录下删掉。
假设这个目录下有很多格子，每个格子可以放一个文件名，还有两个共享变量 in 和 out out 指向下一个要打印的文件名，in 指向目录中下一个空闲的格子。这两个变量能同时被这两个进程访问到。
场景   在某一时刻， 4～6 号格子被需要打印的文件名占用。 在同一时刻，进程A 和 进程B 都决定要打印一个文件，会发生的可能情况：
A 读到 in 的值为 7，然后将 7 存在自己进程的一个变量中 next_free_slot, 此时发生一次时钟中断，CPU 切换到 B，进程 B 也读到 in 的值为 7，同样存放到自己进程变量 next_free_slot 中，结果这两个进程都认为下一个可用格子为 7， B 接着运行，它将需要打印的文件名写入 7 号格子中，并更新 in 的值为 8，然后进程B执行结束，换到 进程A 从上次中断的地方执行， A 检查自己的 next_free_slot 为 7，于是把文件名写入到 7 号格子中，修改 in 的值为 8， 出现的结果就是 进程B 需要打印的文件名被覆盖掉， 导致进程B需要打印的文件不会被打印机打印， 程序也不会发生任何错误。
类似这样的情况， 称为 竞争条件（race condition）</description>
    </item>
    
  </channel>
</rss>
