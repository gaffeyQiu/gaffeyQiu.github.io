<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on gaffey的开发日志</title>
    <link>https://blog.7bao.fun/tags/go/</link>
    <description>Recent content in Go on gaffey的开发日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Feb 2022 11:19:41 +0800</lastBuildDate><atom:link href="https://blog.7bao.fun/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang Sync.Mutex 使用及原理</title>
      <link>https://blog.7bao.fun/p/golang-sync.mutex-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 24 Feb 2022 11:19:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/golang-sync.mutex-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
      <description>Golang Sync.Mutex 使用及原理 使用 func main() { var mu sync.Mutex var count = 0 var wg sync.WaitGroup for i := 0; i &amp;lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() mu.Lock() count++ mu.Unlock() }() } wg.Wait() fmt.Println(count) } 实现 首先看 Mutex 到底是什么数据结构
type Mutex struct { state int32 sema uint32 } sema 信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒 state uint32 字段被分成了四部分,这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，第三位表示是否进入饥饿模式，剩余的位数代表的是等待此锁的 goroutine 数
const ( mutexLocked = 1 &amp;lt;&amp;lt; iota // mutex is locked  mutexWoken //2  mutexStarving //3  mutexWaiterShift = iota //4 } ``` &amp;gt;为了保证锁的公平性，设计上互斥锁有两种状态：正常状态和饥饿状态。 &amp;gt; &amp;gt;`正常模式`下，所有等待锁的goroutine按照FIFO顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。新请求锁的goroutine具有优势：它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。 `如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式`。 &amp;gt; &amp;gt;`饥饿模式`下，锁的所有权将从unlock的gorutine直接交给交给等待队列中的第一个。新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。 &amp;gt; &amp;gt;如果一个等待的goroutine获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。 正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。 #### Mutex.</description>
    </item>
    
    <item>
      <title>Golang Sync.Pool 原理</title>
      <link>https://blog.7bao.fun/p/golang-sync.pool-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 24 Feb 2022 11:19:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/golang-sync.pool-%E5%8E%9F%E7%90%86/</guid>
      <description>Golang Sync.Pool 原理分析  
Get func (p *Pool) Get() interface{} { // 把当前goroutine固定在当前的P上 	l, pid := p.pin() x := l.private // 优先从local的private字段取，快速 	l.private = nil if x == nil { // 从当前的local.shared弹出一个，注意是从head读取并移除 	x, _ = l.shared.popHead() if x == nil { // 如果没有，则去偷一个 	x = p.getSlow(pid) } } runtime_procUnpin() // 如果没有获取到，尝试使用New函数生成一个新的 	if x == nil &amp;amp;&amp;amp; p.New != nil { x = p.New() } return x }  首先，从本地的 private 字段中获取可用元素，因为没有锁，获取元素的过程会非常快 如果没有获取到，就尝试从本地的 shared 获取一个 如果还没有，会使用 getSlow 方法去其它的 shared 中“偷”一个 最后，如果没有获取到，就尝试使用 New 函数创建一个新的。  Put func (p *Pool) Put(x interface{}) { if x == nil { // nil值直接丢弃 	return } l, _ := p.</description>
    </item>
    
    <item>
      <title>Golang Sync.WaitGroup 使用及原理</title>
      <link>https://blog.7bao.fun/p/golang-sync.waitgroup-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 24 Feb 2022 11:17:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/golang-sync.waitgroup-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
      <description>Golang Sync.WaitGroup 使用及原理 使用 func main() { var wg sync.WaitGroup for i := 0; i &amp;lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() fmt.Println(&amp;#34;Hello WaitGroup!&amp;#34;) }() } wg.Wait() } 实现 首先看 waitgroup 到底是什么数据结构
type WaitGroup struct { noCopy noCopy state1 [3]uint32 } nocopy 避免这个结构体被复制的一个技巧，可以告诉go vet工具违反了复制使用的规则 state1 [3]uint32 字段中包含了 waitgroup 的所有状态信息, 根据标准库上自带的注释简单翻译是：state1 由 12 个字节组成，其中将8字节看作64位值，其中高32位存放的是 counter 计数器, 代表目前还未完成的 goroutine个数，低32位存放的是 waiter 计数器, 可以理解成下面这个结构体
type WaitGroup struct { // 代表目前尚未完成的个数 	// WaitGroup.</description>
    </item>
    
    <item>
      <title>Gin 如何动态生成模型 swagger 文档</title>
      <link>https://blog.7bao.fun/p/gin-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B-swagger-%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 01 Dec 2021 19:17:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/gin-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B-swagger-%E6%96%87%E6%A1%A3/</guid>
      <description>在做 API 接口开发时, 一般会统一 API 返回格式, 例如
{ &amp;#34;code&amp;#34;: 200, &amp;#34;data&amp;#34;: { //xxxxx  //xxxxx  }, &amp;#34;message&amp;#34;: &amp;#34;OK&amp;#34; } 在后端代码定义中, 也会定义一个结构体来对应这种结构, 并且, 由于 data 字段里的数据是未知的(与具体业务相关), 所以会定义一个 interface 来接收
type ApiResponse struct { Code int `json:&amp;#34;code&amp;#34;` Msg string `json:&amp;#34;message&amp;#34;` Data interface{} `json:&amp;#34;data&amp;#34;` } 然后根据具体业务响应, 向 data 传入不同的模型, 比如
c.JSON(200, ApiResponse{200, &amp;#34;OK&amp;#34;, User}) 但是这里有个很大的问题, swagger 文档中, 这个接口的返回值该怎么定义?
// @Summary 获取用户信息 // ... // ... // @Success 200 {object} ApiResponse &amp;#34;ok&amp;#34; func GetUser(c *gin.</description>
    </item>
    
  </channel>
</rss>
