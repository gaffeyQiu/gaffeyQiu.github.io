---
title: "[笔记]《Unix网络编程卷一》第二章"
date: 2022-03-12T21:05:30+08:00
tags: ["TCP/IP", "network", "socket"]
categories: ["计算机网络"]
author: "gaffey"
---

## 总图

虽然协议族被称为 TCP/IP ，但除了 TCP/IP 这个两个协议之外还有许多其他成员，如图所示

![](https://ypy.7bao.fun/img/202203122107606.png)



## UDP 用户数据报协议

UDP 是一个简单的传输层协议，应用进程往一个 UDP 套接字写入一个消息，该消息随后被封装到一个 UDP 数据报，该数据报又被封装到一个 IP 数据报，然后发送到目的地，但是 UDP 不保证最终能到达目的地，也不保证各个数据报的顺序，也不保证一个数据报只到达一次，如果你想要一个 UDP 数据报可靠的传输，就需要往应用程序中自己添加这些特性。

当然 UDP 也有好处，UDP的数据有准确的边界，也不用和对端先建立连接，一个 UDP 客户端可以创建一个套接字发送一个数据报给服务器A，然后用同一个套接字发送给服务器B，同样的，服务器可以用一个 UDP 套接字从若干个不同的客户端接收数据报。

## TCP 传输控制协议

TCP 被设计成一个可靠的传输协议， 为了保证可靠，TCP 首先要求客户端和服务端先建立连接，数据交换完毕之后，再关闭连接，在这个基础之上，TCP 提供了确认机制，重传机制， 给每个包添加序号提供排序能力，通过动态预估客户端和服务端往返时间（RTT） 判断当前网络环境是否拥堵提供流量控制等等一系列功能，这些都是不需要应用程序关心的（可能唯一需要处理的就是消息边界问题，俗称TCP粘包和拆包）

> TCP 不能说成是 100% 可靠的协议，因为这是不可能做到的， TCP 的可靠性是数据的可靠传递或故障的可靠通知

### TCP 三次握手

建立一个 TCP 连接时会发生下述情形，前提是服务器必须准备好接受外来的连接。通常调用 `socket`、`bind` 和 `listen` 三个函数来完成，称作被动打开

1. 客户端通过调用 `connect` 发起主动打开，会导致客户TCP发送一个 SYN 分节，它告诉服务器客户端将在连接中发送的数据的初始序列号。
2. 服务器必须确认（ACK）客户端的 SYN， 同时自己也得发送一个 SYN 分节，它含有服务器将在同一连接中发送数据的初始序列号。
3. 客户端你必须确认服务器的SYN

![](https://ypy.7bao.fun/img/202203122206972.png)

### TCP 四次挥手

终止一个TCP连接需要4个过程

1. 某个应用进程调用 `close` （主动关闭），该端的TCP发送一个 FIN 分节，表示数据已发送完毕
2. 接收到这个 FIN 的端执行被动关闭，这个FIN由 TCP 回复一个 ACK，同时将一个文件结束符`EOF` 放到缓冲区等待应用程序读取
3. 一段时间后，这一端的应用程序读到 `EOF` ，由应用程序调用 `close`关闭套接字，这导致这一端的 TCP 也会发送一个 FIN
4. 接收到这个最终的 FIN，然后回复一个 ACK 给对端

![](https://ypy.7bao.fun/img/202203122214019.png)

> 通常来说4次挥手不代表是4次传输，因为有可能步骤一的 FIN 会随着数据一起发送，而步骤2和3 也有可能合并成一次传输

不管是主动关闭放还是被动关闭方，都不需要一定调用 `close` 方法才能触发，当进程退出，它所打开的描述符都会被关闭。

###  TCP状态转换图

![](https://ypy.7bao.fun/img/202203122219652.png)



### TIME_WAIT

主动关闭连接的一方会经历 TIME_WAIT 状态，这个状态的持续时间是 2MSL

主要原因有两个：

1. 让老的重复消息在网络中消失：假设最终的ACK在网络中丢失了，服务器将重新发送 FIN，如果没有 TIME_WAIT 状态，可能这个重发消息就接收不到。这也是为什么主动关闭一方需要进入 TIME_WAIT 状态。
2. 可靠的终止连接： 假设在 1.0.0.1:1500 端口和 1.0.0.2:21 端口之间有一条TCP连接，我们关闭这个连接，过一段时间之后，在相同的IP和端口建立了连接，但是网络中还有上一次重发的的 FIN 消息，可能会重新回到这条连接上被应用程序接受到，误以为这条新建立的连接需要关闭，然后开始走关闭流程。



## SCTP 流控制传输协议

SCTP 结合了 UDP 和 TCP 的优点，提供可靠性、排序、流量控制以及双全工的数据传送，也能记录每条消息的边界，不同的是，一个 SCTP 支持多个 IP 地址，能够在所连接的端点之间提供多个流，每个流各自可靠的按序递送消息。



## 端口号

不管是建立什么连接，都需要 IP 和 端口号，其中这些协议都使用 16 位整数的端口号来区分进程，但是端口号不能随意分配给应用进程， IANA 维护着一份端口号分配清单

1. 0～1023 由 IANA 分配和控制，例如 web 服务器不管 TCP 还是 UDP 都是 80 端口
2. 已登记的端口 1024～49151，这些端口不受 IANA 控制，可以安排给你的服务端程序使用
3. 49152～65535 是动态或者私用端口， IANA 不管这些端口，比如我们浏览网页，需要和web服务器建立一个 TCP 连接，这里我们浏览器会在这个 区间随机使用一个没被占用的端口创建套接字

## 小结

本章讲解了 TCP UDP 和 SCTP 的概念，主要需要掌握 TCP 的三次握手和四次挥手，概念性的东西也比较多，有一个并发服务器的例子，讲的是服务端每接收到一个连接，会 fork 出一个子进程来处理，当数据过来的时候， 主进程会根据[源ip，源端口，目的地ip，目的地端口] 这样的四元组来决定数据是给哪个子进程的。

