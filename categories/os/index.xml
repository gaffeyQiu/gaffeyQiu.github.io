<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OS on gaffey的开发日志</title>
    <link>https://blog.7bao.fun/categories/os/</link>
    <description>Recent content in OS on gaffey的开发日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Feb 2022 10:00:41 +0800</lastBuildDate><atom:link href="https://blog.7bao.fun/categories/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>进程间通信（Inter Process Communication）</title>
      <link>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1inter-process-communication/</link>
      <pubDate>Thu, 24 Feb 2022 10:00:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1inter-process-communication/</guid>
      <description>进程间通信 （Inter Process Communication） 竞争条件（race condition） 前提 书中举了一个脱机打印程序的例子，当一个进程需要打印一个文件，它将需要打印的文件名放在一个特殊的目录下（脱机目录），另一个进程则周期性的检查是否有文件需要打印，如果有就打印这个文件并将文件名从这个目录下删掉。
假设这个目录下有很多格子，每个格子可以放一个文件名，还有两个共享变量 in 和 out out 指向下一个要打印的文件名，in 指向目录中下一个空闲的格子。这两个变量能同时被这两个进程访问到。
场景   在某一时刻， 4～6 号格子被需要打印的文件名占用。 在同一时刻，进程A 和 进程B 都决定要打印一个文件，会发生的可能情况：
A 读到 in 的值为 7，然后将 7 存在自己进程的一个变量中 next_free_slot, 此时发生一次时钟中断，CPU 切换到 B，进程 B 也读到 in 的值为 7，同样存放到自己进程变量 next_free_slot 中，结果这两个进程都认为下一个可用格子为 7， B 接着运行，它将需要打印的文件名写入 7 号格子中，并更新 in 的值为 8，然后进程B执行结束，换到 进程A 从上次中断的地方执行， A 检查自己的 next_free_slot 为 7，于是把文件名写入到 7 号格子中，修改 in 的值为 8， 出现的结果就是 进程B 需要打印的文件名被覆盖掉， 导致进程B需要打印的文件不会被打印机打印， 程序也不会发生任何错误。
类似这样的情况， 称为 竞争条件（race condition）</description>
    </item>
    
    <item>
      <title>[操作系统实验] ucore 环境准备</title>
      <link>https://blog.7bao.fun/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-ucore-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</link>
      <pubDate>Wed, 22 Dec 2021 22:38:41 +0800</pubDate>
      
      <guid>https://blog.7bao.fun/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-ucore-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</guid>
      <description>[实验] ucore 环境准备 环境准备 1. 准备一台装有 ubuntu 操作系统的机器 建议是在虚拟机里面安装一个 ubuntu， 避免对自己机器的影响， 我安装的是当时最新版本ubuntu桌面端
 https://ypy.7bao.fun/img/20211222204823.png 
ps：小豹子挺可爱的
2. 安装环境  gcc: 编译 c++ make: 自动编译或测试代码 gdb: 调试代码 cgdb: 字符方式调试代码 qemu: 调试内核，实验中搭配 cgdb 使用 git: 获取实验所需代码 vscode: 编写代码 vim: 偶尔也会在终端用 vim 查看代码  3. 实验资料 https://github.com/chyyuu/os_course_info
Introduction
Introduction
4. 获取代码 根据实验资料查到项目地址，非常友好的开源了，没有放在清华的内网。
git clone &amp;lt;https://github.com/chyyuu/os_kernel_lab.git 这样获取到的代码默认是 rust 语言实现的，目前我学习的是 c 语言实现，所以切换到 master 分支 （后续实验完成了希望能用 rust 也实现一遍)
git checkout master 5.验证环境 可以参考视频 学堂在线 2.7 演示实验操作过程</description>
    </item>
    
  </channel>
</rss>
